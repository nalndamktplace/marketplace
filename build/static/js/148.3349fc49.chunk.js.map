{"version":3,"file":"static/js/148.3349fc49.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/constants/src.ts/strings.ts","../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/url-json-rpc-provider.ts","../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts","../node_modules/ethers/src.ts/_version.ts","../node_modules/ethers/src.ts/ethers.ts","../node_modules/ethers/src.ts/index.ts"],"sourcesContent":["// NFKC (composed)             // (decomposed)\nexport const EtherSymbol = \"\\u039e\";  // \"\\uD835\\uDF63\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\nexport interface WebSocketLike {\n    onopen: (...args: Array<any>) => any;\n    onmessage: (...args: Array<any>) => any;\n    onerror: (...args: Array<any>) => any;\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string | WebSocketLike, network?: Networkish) {\n\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        if (typeof(url) === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        } else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this.websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket(): WebSocketLike { return this._websocket; }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this.websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this.websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this.websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this.websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this.websocket.close(1000);\n    }\n}\n","\n\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { CommunityResourcable } from \"./formatter\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\n\ntype getUrlFunc = (network: Network, apiKey: string) => string | ConnectionInfo;\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    async detectNetwork(): Promise<Network> {\n        let network = this.network;\n        if (network == null) {\n            network = await super.detectNetwork();\n\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // If still not set, set it\n            if (this._network == null) {\n                // A static network does not support \"any\"\n                defineReadOnly(this, \"_network\", network);\n\n                this.emit(\"network\", network, null);\n            }\n        }\n        return network;\n    }\n}\n\nexport abstract class UrlJsonRpcProvider extends StaticJsonRpcProvider implements CommunityResourcable {\n    readonly apiKey: any;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n\n        // Normalize the Network and API Key\n        network = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n        apiKey = getStatic<(apiKey: string) => string>(new.target, \"getApiKey\")(apiKey);\n\n        const connection = getStatic<getUrlFunc>(new.target, \"getUrl\")(network, apiKey);\n\n        super(connection, network);\n\n        if (typeof(apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly<any, any>(this, key, apiKey[key]);\n            });\n        }\n    }\n\n    _startPending(): void {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n\n    isCommunityResource(): boolean {\n        return false;\n    }\n\n    getSigner(address?: string): JsonRpcSigner {\n        return logger.throwError(\n            \"API provider does not support signing\",\n            Logger.errors.UNSUPPORTED_OPERATION,\n            { operation: \"getSigner\" }\n        );\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return Promise.resolve([]);\n    }\n\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey: any): any {\n        return apiKey;\n    }\n\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network: Network, apiKey: any): string | ConnectionInfo {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\": case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\": case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n","export const version = \"ethers/5.6.9\";\n","\"use strict\";\n\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\n\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\n\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\n\nimport * as constants from \"@ethersproject/constants\";\n\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\n\nimport { Wordlist, wordlists} from \"@ethersproject/wordlists\";\n\nimport * as utils from \"./utils\";\n\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n\n////////////////////////\n// Types\n\nimport { BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike, Signature } from \"@ethersproject/bytes\";\nimport { Transaction, UnsignedTransaction } from \"@ethersproject/transactions\";\n\n\n////////////////////////\n// Compile-Time Constants\n\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\n\nconst logger = new Logger(version);\n\n////////////////////////\n// Types\n\nimport {\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface\n} from \"@ethersproject/contracts\";\n\n\n////////////////////////\n// Exports\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n};\n\n","\"use strict\";\n\n// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js\n\nimport * as ethers from \"./ethers\";\n\ntry {\n    const anyGlobal = (window as any);\n\n    if (anyGlobal._ethers == null) {\n        anyGlobal._ethers = ethers;\n    }\n} catch (error) { }\n\nexport { ethers };\n\nexport {\n    Signer,\n\n    Wallet,\n    VoidSigner,\n\n    getDefaultProvider,\n    providers,\n\n    BaseContract,\n    Contract,\n    ContractFactory,\n\n    BigNumber,\n    FixedNumber,\n\n    constants,\n    errors,\n\n    logger,\n\n    utils,\n\n    wordlists,\n\n\n    ////////////////////////\n    // Compile-Time Constants\n\n    version,\n\n\n    ////////////////////////\n    // Types\n\n    ContractFunction,\n    ContractReceipt,\n    ContractTransaction,\n    Event,\n    EventFilter,\n\n    Overrides,\n    PayableOverrides,\n    CallOverrides,\n\n    PopulatedTransaction,\n\n    ContractInterface,\n\n    BigNumberish,\n\n    Bytes,\n    BytesLike,\n\n    Signature,\n\n    Transaction,\n    UnsignedTransaction,\n\n    Wordlist\n} from \"./ethers\";\n"],"names":["EtherSymbol","WS","WebSocket","Error","error","logger","Logger","version","throwError","operation","BigNumber","defineReadOnly","JsonRpcProvider","WebSocketProvider","NextId","url","network","errors","UNSUPPORTED_OPERATION","_pollingInterval","_wsReady","connection","websocket","send","forEach","id","payload","onmessage","messageEvent","data","result","String","request","undefined","Object","_requests","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","value","blockNumber","rid","Promise","resolve","reject","stringify","jsonrpc","tag","param","subIdPromise","_subIds","all","then","subId","event","type","_subscribe","from","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","onopen","_events","e","log","length","listenerCount","readyState","CONNECTING","onerror","close","keys","getStatic","_super","detectNetwork","call","StaticJsonRpcProvider","UNKNOWN_ERROR","_network","UrlJsonRpcProvider","apiKey","checkAbstract","key","address","NOT_IMPLEMENTED","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","replace","throwArgumentError","host","name","arguments","allowGzip","throttleCallback","attempt","showThrottleMessage","getHost","AnkrProvider","projectSecret","user","password","CloudflareProvider","perform","blockTag","hexlify","hexValue","isHexString","deepCopy","fetchJson","BaseProvider","getTransactionPostData","transaction","gasLimit","status","join","getResult","JSON","toLowerCase","indexOf","throttleRetry","getJsonResult","maxFeePerGs","gasPrice","set","checkLogTag","parseInt","substring","checkError","SERVER_ERROR","match","CALL_EXCEPTION","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","EtherscanProvider","getBaseUrl","module","maxPriorityFeePerGas","query","reduce","getPostUrl","getUrl","map","getPostData","procFunc","throttleSlotInterval","isCommunityResource","payloadStr","headers","fetch","position","hex","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","storageKeys","args","fromBlock","nonce","toBlock","topics","topic0","logs","blocks","i","blockHash","getBlock","parseFloat","ethusd","addressOrName","startBlock","resolveName","startblock","endblock","sort","tx","creates","contractAddress","item","transactionResponse","timeStamp","timestamp","Provider","poll","shuffled","now","Date","getTime","checkNetworks","networks","middle","slice","Math","floor","a","b","abs","serialize","isBigNumber","toString","Array","isArray","v","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","wait","func","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","start","tally","c","count","check","getProcessFunc","cancelled","oncePoll","ceil","_highestBlockNumber","getRunner","currentBlockNumber","getEtherPrice","ensAddress","getStorageAt","confirmations","transactions","median","waitForSync","getLogs","FallbackProvider","providers","providerConfigs","configOrProvider","index","isProvider","stallTimeout","priority","freeze","total","networkOrReady","getNetwork","sendTransaction","maxDelta","getBlockNumber","results","first","t0","inflightWeight","runner","chainId","staller","backend","waiting","push","race","errorCode","props","reason","done","values","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","apiKeyObj","assertArgument","argument","JsonRpcBatchProvider","_nextId","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","_defaultProvider","Web3Provider","anyGlobal","window","_ethers","ethers"],"sourceRoot":""}